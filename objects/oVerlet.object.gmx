<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Verlet integrator variables
// enum for indexing verlet attribs.
enum eVERLET
{
    POS,
    POS_PREV,
    ACCEL
}

// enum for indexing link / constraint attribs.
enum eLINK
{
    P1,
    P2,
    DIST
}

// list of points / verlets
verlets = ds_list_create();

// list of links / constraints
links = ds_list_create();

// physics params
timeScale = 1.0;
velGravity = 0.5; // how much velocity will be accumulated to simulate gravity
velLinkTensionFactor = 0.3; // how much force will be applied for points that is on link / constraints
linkIterations = 3; // how many times to update the links (higher means more accurate simulation of linked verlet particles &amp; lesser performance)
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Build body
bodyScale = 2;

bodyWidth = sprite_get_height(sprBody) * bodyScale;
bodyWidthHalf = bodyWidth * 0.5;
bodyheight = 24 * bodyScale;
bodyRootX = room_width * 0.5;
bodyRootY = room_height * 0.5;
bodyRoot = zv_add_verlet(bodyRootX, bodyRootY, 0, 0);

// right arm
armRightRoot = zv_add_verlet(bodyRootX + bodyWidthHalf, bodyRootY + 3, 0, 0);
armRightJoint = zv_add_verlet(bodyRootX + bodyWidthHalf + 40, bodyRootY + 3, 0, 0);
armRightLeaf = zv_add_verlet(bodyRootX + bodyWidthHalf + 80, bodyRootY + 3, 0, 0);
zv_add_link(armRightRoot, armRightJoint);
zv_add_link(armRightJoint, armRightLeaf);

// left arm
armLeftRoot = zv_add_verlet(bodyRootX - bodyWidthHalf, bodyRootY + 3, 0, 0);
armLeftJoint = zv_add_verlet(bodyRootX - bodyWidthHalf - 64, bodyRootY + 3, 0, 0);
armLeftLeaf = zv_add_verlet(bodyRootX - bodyWidthHalf - 128, bodyRootY + 3, 0, 0);
zv_add_link(armLeftRoot, armLeftJoint);
zv_add_link(armLeftJoint, armLeftLeaf);

// right leg
legRightRoot = zv_add_verlet(bodyRootX + bodyWidthHalf - 3, bodyRootY + bodyheight - 2, 0, 0);
legRightJoint = zv_add_verlet(bodyRootX + bodyWidthHalf - 3, bodyRootY + bodyheight - 2 + 64, 0, 0);
legRightLeaf = zv_add_verlet(bodyRootX + bodyWidthHalf - 3, bodyRootY + bodyheight - 2 + 128, 0, 0);
zv_add_link(legRightRoot, legRightJoint);
zv_add_link(legRightJoint, legRightLeaf);

// left leg
legLeftRoot = zv_add_verlet(bodyRootX - bodyWidthHalf + 3, bodyRootY + bodyheight - 2, 0, 0);
legLeftJoint = zv_add_verlet(bodyRootX - bodyWidthHalf + 3, bodyRootY + bodyheight - 2 + 64, 0, 0);
legLeftLeaf = zv_add_verlet(bodyRootX - bodyWidthHalf + 3, bodyRootY + bodyheight - 2 + 128, 0, 0);
zv_add_link(legLeftRoot, legLeftJoint);
zv_add_link(legLeftJoint, legLeftLeaf);

// head (for rotation)
headRoot = zv_add_verlet(bodyRootX, bodyRootY - 24, 0, 0);
zv_add_link(headRoot, bodyRoot);
zv_add_link(headRoot, armLeftRoot);
zv_add_link(headRoot, armRightRoot);

// surface
boybodySurf = surface_create(window_get_width(), window_get_height());

time = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update
time += timeScale;

// make body bounce around
bodyRootX = room_width * 0.5 + dsin(time * (360 / room_speed * 0.5)) * 42;
bodyRootY = room_height * 0.5 + dsin(time * (360 / room_speed)) * 24;
zv_set_pos(bodyRoot, bodyRootX, bodyRootY);

// attatch limbs to body
zv_set_pos(armRightRoot, bodyRootX + bodyWidthHalf, bodyRootY + 3);
zv_set_pos(armLeftRoot, bodyRootX - bodyWidthHalf, bodyRootY + 3);
zv_set_pos(legRightRoot, bodyRootX + bodyWidthHalf - 3, bodyRootY + bodyheight - 2);
zv_set_pos(legLeftRoot, bodyRootX - bodyWidthHalf + 3, bodyRootY + bodyheight - 2);

// point right hand
var _pos = zv_get_pos(armRightLeaf);
var _dx = mouse_x - _pos[@ 0], _dy = mouse_y - _pos[@ 1];
zv_set_accel(armRightLeaf, _dx * 0.05, _dy * 0.05);
zv_damp(armRightLeaf, 0.1);

// try to stabilize head
var _pos = zv_get_pos(headRoot);
var _dx = bodyRootX - _pos[@ 0], _dy = (bodyRootY - 24) - _pos[@ 1];
zv_set_accel(headRoot, _dx * 0.005, _dy * 0.08);
zv_damp(headRoot, 0.05);

// shake limbs on certain intervals
if (time &amp; 63 == 0)
{
    var _mag = 16;
    randomize();
    zv_set_accel(armLeftLeaf, random_range(-_mag, _mag), random_range(-_mag, _mag));
    zv_set_accel(armRightLeaf, random_range(-_mag, _mag), random_range(-_mag, _mag));
    zv_set_accel(legLeftLeaf, random_range(-_mag, _mag), random_range(-_mag, _mag));
    zv_set_accel(legRightLeaf, random_range(-_mag, _mag), random_range(-_mag, _mag));
}

// Update verlet &amp; update constraints
event_user(0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="61">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>timeScale = clamp(timeScale - 0.1, 0.0, 5.0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="60">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>timeScale = clamp(timeScale + 0.1, 0.0, 5.0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update all
// calculate delta time
var _secperstep = 1.0 / room_speed; // Desired : 1 / 60 seconds for each frame
var _step = min(((delta_time * 0.000001) / _secperstep), 4.0) * timeScale; // Quick fix : cap the delta time to prevent the simulation jerking out
var _steppow = _step * _step;

// integrate particles
for (var i=0; i&lt;ds_list_size(verlets); i++)
{
    var _data = verlets[| i];
    var _posprev = _data[@ eVERLET.POS_PREV];
    var _pos = _data[@ eVERLET.POS];
    var _acc = _data[@ eVERLET.ACCEL];
    
    var _posx = _pos[@ 0];
    var _posy = _pos[@ 1];
    var _velx = (_posx - _posprev[@ 0]);
    var _vely = (_posy - _posprev[@ 1]);
    
    // Update previous position &amp; accumulate velocities to current position
    _posprev[@ 0] = _posx;
    _posprev[@ 1] = _posy;
    _pos[@ 0] += _velx + _acc[@ 0] * _steppow;
    _pos[@ 1] += _vely + _acc[@ 1] * _steppow;
    
    _acc[@ 0] = 0;
    _acc[@ 1] = velGravity;
}

// update constraints
for (var k=0; k&lt;linkIterations; k++)
{
    for (var i=0; i&lt;ds_list_size(links); i++)
    {
        var _data = links[| i];
        
        // fetch both particles
        var _p1 = verlets[| _data[@ eLINK.P1]], _p2 = verlets[| _data[@ eLINK.P2]];
        var _p1pos = _p1[@ eVERLET.POS], _p2pos = _p2[@ eVERLET.POS];
        
        // calculate distance between both particle and use that to make two particle "closer" to each other
        // and apply appropirate force
        var _linkdist = _data[@ eLINK.DIST];
        var _pointdistx = _p1pos[@ 0] - _p2pos[@ 0], _pointdisty = _p1pos[@ 1] - _p2pos[@ 1];
        var _pointdist = sqrt(_pointdistx * _pointdistx + _pointdisty * _pointdisty);
        
        if (_pointdist &gt; 0)
        {
            var _distdelta = (_linkdist - _pointdist) / _pointdist;
            var _movefactorx = _pointdistx * _distdelta * velLinkTensionFactor, _movefactory = _pointdisty * _distdelta * velLinkTensionFactor;

            _p1pos[@ 0] += _movefactorx; _p1pos[@ 1] += _movefactory;
            _p2pos[@ 0] -= _movefactorx; _p2pos[@ 1] -= _movefactory;
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// (DEBUG) Draw verlets &amp; links
/*
// verlet points
draw_set_alpha(0.5);
for (var i=0; i&lt;ds_list_size(verlets); i++)
{
    var _data = verlets[| i];
    var _pos = _data[@ eVERLET.POS];
    var _vel = _data[@ eVERLET.VEL];
    
    draw_set_colour(c_black);
    draw_rectangle(_pos[@ 0] - 4, _pos[@ 1] - 4, _pos[@ 0] + 4, _pos[@ 1] + 4, false);
    draw_set_colour(c_red);
    draw_arrow(_pos[@ 0], _pos[@ 1], _pos[@ 0] + _vel[@ 0], _pos[@ 1] + _vel[@ 1], 4);
}

// link / constraints
for (var i=0; i&lt;ds_list_size(links); i++)
{
    var _data = links[| i];
    var _p1 = verlets[| _data[@ eLINK.P1]], _p2 = verlets[| _data[@ eLINK.P2]];
    var _p1pos = _p1[@ eVERLET.POS], _p2pos = _p2[@ eVERLET.POS];
    
    draw_set_colour(c_blue);
    draw_line(_p1pos[@ 0], _p1pos[@ 1], _p2pos[@ 0], _p2pos[@ 1]);
}

draw_set_alpha(1.0);
draw_set_colour(c_black);
*/
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw boy body deluxe[tm] to surface
// surface check
if (!surface_exists(boybodySurf))
{
    boybodySurf = surface_create(window_get_width(), window_get_height());
}

draw_set_colour(c_white);
surface_set_target(boybodySurf);
draw_clear_alpha(0, 0);

/// FPS counter &amp; pseudo-credit
draw_set_font(fntDef);
draw_set_halign(1);
var _centerx = room_width * 0.5;
var _ang = dsin(time * (360 / room_speed)) * 4;
draw_text_transformed(_centerx, 42, "FPS : " + string(fps), 6, 6, _ang);
draw_text_transformed(_centerx, 142, "(" + string(fps_real) + ")", 3, 3, _ang);
draw_text_transformed(_centerx, 10, "MOUSE WHEEL : MODIFY TIMESCALE (" + string(timeScale) + ")", 2, 2, 0);
draw_text_transformed(_centerx, room_height - 42, "MMXIX ZIK", 2, 2, 0);

/// sprites (back)
var _modelscale = bodyScale;
var _bodypos = zv_get_pos(bodyRoot);

// body
draw_sprite_ext(sprBody, 0, bodyRootX, bodyRootY, _modelscale, _modelscale, -90, c_white, 1.0);

// head
var _headpos = zv_get_pos(headRoot);
var _headdir = point_direction(_bodypos[@ 0], _bodypos[@ 1], _headpos[@ 0], _headpos[@ 1]);
draw_sprite_ext(sprBody, 1, bodyRootX, bodyRootY, _modelscale, _modelscale, _headdir, c_white, 1.0);

/// Let the bezier batch begin
// we batch the bezier curves into one big primitive trying to juice out those sweet FPS
zb_batch_begin();

/// ARM R bezier limb
// zv_get_pos() returns the position of verlet particle of given index.
// in this case, we're fetching the positions of 3 particles that forms the right arm limb.
var _rarmpos1 = zv_get_pos(armRightRoot), _rarmpos2 = zv_get_pos(armRightJoint), _rarmpos3 = zv_get_pos(armRightLeaf);

// here, zb_batch_quadratic_spr_alt() draws deformed sprite along the Quadratic Bezier curve's surface
// with first 3 arguments defines the 3 control points of Quadratic bezier curve.
zb_batch_quadratic_spr_alt(_rarmpos1, _rarmpos2, _rarmpos3, sprLimb, 0, 6 * _modelscale, 8, false);

/// ARM L bezier limb
var _larmpos1 = zv_get_pos(armLeftRoot), _larmpos2 = zv_get_pos(armLeftJoint), _larmpos3 = zv_get_pos(armLeftLeaf);
zb_batch_quadratic_spr_alt(_larmpos1, _larmpos2, _larmpos3, sprLimb, 0, 6 * _modelscale, 8, true);

/// LEG R bezier limb
var _rlegpos1 = zv_get_pos(legRightRoot), _rlegpos2 = zv_get_pos(legRightJoint), _rlegpos3 = zv_get_pos(legRightLeaf);
zb_batch_quadratic_spr_alt(_rlegpos1, _rlegpos2, _rlegpos3, sprLimb, 1, 6 * _modelscale, 8, false);

/// LEG L bezier limb
var _llegpos1 = zv_get_pos(legLeftRoot), _llegpos2 = zv_get_pos(legLeftJoint), _llegpos3 = zv_get_pos(legLeftLeaf);
zb_batch_quadratic_spr_alt(_llegpos1, _llegpos2, _llegpos3, sprLimb, 1, 6 * _modelscale, 8, true);

/// batch end
zb_batch_end();

/// sprites (front)
// Hand R
var _rarmderiv = zb_quadratic_get_deriv(_rarmpos1, _rarmpos2, _rarmpos3, 1); // get the tangent of limb's "last" point (used for determining the angle of sprites)
draw_sprite_ext(sprBody, 2, _rarmpos3[@ 0], _rarmpos3[@ 1], _modelscale, _modelscale, radtodeg(arctan2(-_rarmderiv[@ 1], _rarmderiv[@ 0])), c_white, 1.0);

// Hand L
var _larmderiv = zb_quadratic_get_deriv(_larmpos1, _larmpos2, _larmpos3, 1);
draw_sprite_ext(sprBody, 2, _larmpos3[@ 0], _larmpos3[@ 1], _modelscale, -_modelscale, radtodeg(arctan2(-_larmderiv[@ 1], _larmderiv[@ 0])), c_white, 1.0);

// Foot R
var _rlegderiv = zb_quadratic_get_deriv(_rlegpos1, _rlegpos2, _rlegpos3, 1);
draw_sprite_ext(sprBody, 3, _rlegpos3[@ 0], _rlegpos3[@ 1], _modelscale, _modelscale, radtodeg(arctan2(-_rlegderiv[@ 1], _rlegderiv[@ 0])), c_white, 1.0);

// Foot L
var _llegderiv = zb_quadratic_get_deriv(_llegpos1, _llegpos2, _llegpos3, 1);
draw_sprite_ext(sprBody, 3, _llegpos3[@ 0], _llegpos3[@ 1], _modelscale, -_modelscale, radtodeg(arctan2(-_llegderiv[@ 1], _llegderiv[@ 0])), c_white, 1.0);

surface_reset_target();
draw_set_colour(c_black);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw background &amp; surface
draw_background_tiled(background0, time, time);
draw_surface_ext(boybodySurf, 8, 8, 1, 1, 0, c_black, 0.4);
draw_surface(boybodySurf, 0, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
